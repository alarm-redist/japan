---
title: "23_ms_aichi"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#knitr::opts_knit$set(root.dir = '/Users/kentoyamada/Desktop/ALARM Project/jcdf')
#knitr::opts_knit$set(root.dir = '/home/kentoyamada/R/jcdf/')
```

# I. Simulations
## 1. Set Up and Data Cleaning Process
### 1.1 Set Up
```{r eval=FALSE}
library(tidyverse)
set.seed(12345)
# pull functions from jcdf
# set working directory to the function folder
setwd("R")
files.sources = list.files()
sapply(files.sources, source)
# set working directory back to `jcdf`
setwd("..")
```

#### Define Prefectural Data 
```{r}
sim_type <- "smc"
nsims <- 25000
pref_code <- 23
pref_name <- "aichi"
lakes_removed <- c() 
ndists_new <- 16
ndists_old <- 15
n_split <- 3
```

### 1.2.Download and Clean Census Data
```{r warning=FALSE, message=FALSE}
# download census shapefile
pref_raw <- download_shp(pref_code)
dem_pops <- download_pop_demographics(pref_code)
# download 2020 census data
total <- download_2020_census(type = "total")
foreigner <- download_2020_census(type = "foreigner")
#Clean 2020 census
census2020 <- clean_2020_census(total = total, foreigner = foreigner)
# download historical boundary data
old_boundary <- download_old_shp(pref_code = pref_code)
# populations based on historical boundaries
pop_by_old_boundary <- download_2015pop_old(pref_code = pref_code)
```

### 1.3 Use `clean_jcdf()` function to clean census data
```{r warning=FALSE, message=FALSE}
pref <- pref_raw %>%
  clean_jcdf() %>%
  dplyr::select(code, KIHON1, JINKO, geometry)
pref <- calc_kokumin(pref, dem_pops)
#Estimate 2020 pop. <- estimate_2020_pop(pref, census2020) %>%
  dplyr::select(code, KIHON1, pop_estimate, geometry) %>%
  dplyr::rename(subcode = KIHON1, pop = pop_estimate)
```

### 1.4 Merge together gun
Under the enacted plan, all the gun in Aichi prefecture are respected under the status quo. Thus, we merge together the gun so as not to split them.
```{r}
#merge Aichi gun
aichi <- pref %>%
  dplyr::filter(code == 23302)
aichi$code <- 23300
aichi <- aichi %>%
  dplyr::group_by(code) %>%
  dplyr::summarise(pop = sum(pop), geometry = sf::st_union(geometry))
aichi$subcode <- "0000"

#merge Nishikasugai gun
nishikasugai <- pref %>%
  dplyr::filter(code == 23342)
nishikasugai$code <- 23340
nishikasugai <- nishikasugai %>%
  dplyr::group_by(code) %>%
  dplyr::summarise(pop = sum(pop), geometry = sf::st_union(geometry))
nishikasugai$subcode <- "0000"

#merge Niwa gun
niwa <- pref %>%
  dplyr::filter(code %in% c(23361, 23362))
niwa$code <- 23360
niwa <- niwa %>%
  dplyr::group_by(code) %>%
  dplyr::summarise(pop = sum(pop), geometry = sf::st_union(geometry))
niwa$subcode <- "0000"

#merge Ama gun
ama <- pref %>%
  dplyr::filter(code %in% c(23424, 23425, 23427))
ama$code <- 23420
ama <- ama %>%
  dplyr::group_by(code) %>%
  dplyr::summarise(pop = sum(pop), geometry = sf::st_union(geometry))
ama$subcode <- "0000"

#merge Chita gun
chita <- pref %>%
  dplyr::filter(code %in% c(23441, 23442, 23445, 23446, 23447))
chita$code <- 23440
chita <- chita %>%
  dplyr::group_by(code) %>%
  dplyr::summarise(pop = sum(pop), geometry = sf::st_union(geometry))
chita$subcode <- "0000"

#merge Nukata gun
nukata <- pref %>%
  dplyr::filter(code == 23501)
nukata$code <- 23500
nukata <- nukata %>%
  dplyr::group_by(code) %>%
  dplyr::summarise(pop = sum(pop), geometry = sf::st_union(geometry))
nukata$subcode <- "0000"

#merge Kitashitara gun
kitashitara <- pref %>%
  dplyr::filter(code %in% c(23561, 23562, 23563))
kitashitara$code <- 23560
kitashitara <- kitashitara %>%
  dplyr::group_by(code) %>%
  dplyr::summarise(pop = sum(pop), geometry = sf::st_union(geometry))
kitashitara$subcode <- "0000"

#merge back together
pref_non_gun <- pref %>%
  dplyr::filter(code %in% c(23302, 
                           23342,
                           23361, 23362,
                           23424, 23425, 23427,
                           23441, 23442, 23445, 23446, 23447,
                           23501,
                           23561, 23562, 23563) == FALSE)

#now pref is an object with 0 gun splits
pref <- dplyr::bind_rows(pref_non_gun, aichi, nishikasugai, niwa, ama, chita, 
                         nukata, kitashitara)
```

### 1.5 Define "Koiki-renkei" Areas
```{r}
#assign which municipality belongs to which koiki renkei area
kinuura_koiki <- c(23210, 23225, 23227, 23300)  #23300 Aichigun, Togo cho
```

## 2. Run Simulations 

### 2.1 Finalize pref object
No additional steps needed

### 2.2 Make adjacency graph
```{r}
prefadj <- redist::redist.adjacency(pref)
```

### 2.3 Add edges to adjacency graph
The add_ferries() function connects 西尾市一色町佐久島 (no: 4251, code: 23213, subcode: 7240) with 西尾市一色町坂田新田 (no: 4239, code: 23213, subcode: 7120).

In addition, 名古屋市港区金城ふ頭 (no: 973, code: 23111, subcode: 0460) appears to be disconnected. We manually connect it to three areas: 名古屋市港区空見町(code: 23111, subcode: 1080), 名古屋市港区潮見町 (code: 23111, subcode: 0740), and 愛知県海部郡飛島村金岡(code: 23420)

We also manually connect 常滑市セントレア町(no: 4403, code: 23216, subcode: 0960) to 常滑市りんくう町 (code: code: 23216, subcode: 0950)
```{r}
if(check_ferries(pref_code) == TRUE){
  # add ferries
  ferries <- add_ferries(pref)
  prefadj <- geomander::add_edge(prefadj,
                                 ferries[, 1],
                                 ferries[, 2],
                                 zero = TRUE)
}
```

```{r}
prefadj <- geomander::add_edge(prefadj, 
                               which(pref$code == 23111 & pref$subcode == "0460"), #名古屋市港区金城ふ頭 
                               which(pref$code == 23111 & pref$subcode == "1080")) #名古屋市港区空見町
prefadj <- geomander::add_edge(prefadj, 
                               which(pref$code == 23111 & pref$subcode == "0460"), #名古屋市港区金城ふ頭 
                               which(pref$code == 23111 & pref$subcode == "0740")) #名古屋市港区潮見町
prefadj <- geomander::add_edge(prefadj, 
                               which(pref$code == 23111 & pref$subcode == "0460"),  #名古屋市港区金城ふ頭 
                               which(pref$code == 23420)) #愛知県海部郡飛島村金岡
prefadj <- geomander::add_edge(prefadj, 
                               which(pref$code == 23216 & pref$subcode == "0960"), #常滑市セントレア町 
                               which(pref$code == 23216 & pref$subcode == "0950")) #常滑市りんくう町
```

### 2.4 Define redist.map object
```{r}
pref_map <- redist::redist_map(pref,
                               ndists = ndists_new,
                               pop_tol= 0.15,
                               total_pop = pop,
                               adj = prefadj)
```

###2.5 Run Simulation
```{r}
constr = redist::redist_constr(pref_map)
constr = redist::add_constr_splits(constr, strength= 100)
constr = redist::add_constr_multisplits(constr, strength = 200)

pref_smc <- redist::redist_smc(
  map = pref_map,
  nsims = nsims,
  counties = pref$code,
  constraints = constr
)
```

### 2.6 Save results of simulation
```{r}
saveRDS(pref_smc, paste("simulation/",
                        as.character(pref_code),
                        "_",
                        as.character(pref_name),
                        "_",
                        as.character(sim_type),
                        "_",
                        as.character(nsims),
                        "_0",
                        ".Rds",
                        sep = ""))
```

# II. Analysis
## 1. Get Optimal Plan
### 1.1 Extract Plans
```{r}
pref_smc_plans <- redist::get_plans_matrix(pref_smc)
```

### 1.2 Calculate Max:min ratio
```{r}
wgt_smc <- simulation_weight_disparity_table(pref_smc)
```

### 1.3 Count municipality/gun/koiki renkei splits
Whereas `count_splits()` counts the total number of splits, `redist.splits()` counts the number of geographical units that are split.
```{r}
#assign koiki_renkei area codes for simulation with 0 split
koiki_1 <- pref$code
koiki_1[koiki_1 %in% kinuura_koiki] <- 1
koiki_1[koiki_1 %in% kinuura_koiki == FALSE] <- 0

#count the number of koiki-renkei areas that are split
koiki_split <- redist::redist.splits(pref_smc_plans, koiki_1)

#count the number of municipality splits
num_mun_split <- count_splits(pref_smc_plans, pref_map$code)
mun_split <- redist::redist.splits(pref_smc_plans, pref_map$code)
```

### 1.4 Compile Results
The table created includes information on the max:min ratio as well as the number of municipality/gun/koiki-renkei splits. We also check whether there are cases where a municipality is split into more than 2 districts, in which case such results are filtered out.

```{r}
results <- data.frame(matrix(ncol = 0, nrow = nrow(wgt_smc)))
results$max_to_min <- wgt_smc$max_to_min
#number of municipality splits
results$nun_mun_split <- num_mun_split
results$mun_split <- mun_split
#check whether there are cases where a municipality is split into more than 2 districts
results$multi <-  results$nun_mun_split - results$mun_split
#number of koiki renkei area splits
results$koiki_split <- koiki_split
results$index <- 1:nrow(wgt_smc)
```

```{r}
# Amagun (code: 23420) is consisted of three disconnected municipalities. There are four ways to avoid separating Amagun into different districts:
#1. Ensuring that Amagun (code: 23420), Yatomishi (code: 23235),and Amashi (code: 23237) are in the same district
#2. Ensuring that Amagun (code: 23420), Minatoku (code: 23111), and Amashi (code: 23237) are in the same district
#3. Ensuring that Amagun (code: 23420), Yatomishi (code: 23235),and Nakagawaku (code: 23110) are in the same district
#4. Ensuring that Amagun (code: 23420), Minatoku (code: 23111), and Nakagawaku (code: 23110) are in the same district

contiguous_1 <- 1:nsims
for(i in 1:nsims){
   contiguous_1[i] <- 
     #Returns 1 if  Amagun (code: 23420), Yatomishi (code: 23235), and Amashi (code: 23237) are in the same district
     max(as.integer(pref_smc_plans[,i][which(pref$code == 23420)] == pref_smc_plans[,i][which(pref$code == 23235)])) *
     max(as.integer(pref_smc_plans[,i][which(pref$code == 23420)] == pref_smc_plans[,i][which(pref$code == 23237)])) +
     #Returns 1 if  Amagun (code: 23420), Minatoku (code: 23111), and Amashi (code: 23237) are in the same district
     max(as.integer(pref_smc_plans[,i][which(pref$code == 23420)] == pref_smc_plans[,i][which(pref$code == 23111)])) *
     max(as.integer(pref_smc_plans[,i][which(pref$code == 23420)] == pref_smc_plans[,i][which(pref$code == 23237)])) +
     #Returns 1 if  Amagun (code: 23420), Yatomishi (code: 23235), and Nakagawaku (code: 23110) are in the same district
     max(as.integer(pref_smc_plans[,i][which(pref$code == 23420)] == pref_smc_plans[,i][which(pref$code == 23235)])) *
     max(as.integer(pref_smc_plans[,i][which(pref$code == 23420)] == pref_smc_plans[,i][which(pref$code == 23110)])) +
     #Returns 1 if Amagun (code: 23420), Minatoku (code: 23111), and Nakagawaku (code: 23110) are in the same district
     max(as.integer(pref_smc_plans[,i][which(pref$code == 23420)] == pref_smc_plans[,i][which(pref$code == 23111)])) *
     max(as.integer(pref_smc_plans[,i][which(pref$code == 23420)] == pref_smc_plans[,i][which(pref$code == 23110)])) 
}
results$contiguous_1 <- contiguous_1

# Chitagun (code: 23440) is consisted of two disconnected parts. In order to avoid separating Chitagun into different districts, we must ensure that Chitagun is in the same district as either Handa-shi or Tokoname-shi.

contiguous_2 <- 1:nsims
for(i in 1:nsims){
   contiguous_2[i] <- 
     #Returns 1 if  Chitagun (code: 23440) and Handa-shi (code: 23205) are in the same district.
     max(as.integer(pref_smc_plans[,i][which(pref$code == 23440)] == pref_smc_plans[,i][which(pref$code == 23205)])) +
     #Returns 1 if  Chitagun (code: 23440) and Tokoname-shi (code: 23216) are in the same district
     max(as.integer(pref_smc_plans[,i][which(pref$code == 23440)] == pref_smc_plans[,i][which(pref$code == 23216)])) 
}
results$contiguous_2 <- contiguous_2
```

### 1.5  Optimal Plan
The optimal plan is the plan that has the smallest max:min ratio out of all plans that do not have discontiguous districts and do not split a municipality into more than 2 districts.
```{r}
functioning_results <- results[which(results$multi == 0 & results$contiguous_1 > 0 & results$contiguous_2 > 0), ]
optimal <- functioning_results$index[which(functioning_results$max_to_min ==
                                     min(functioning_results$max_to_min))][1]
results[optimal,]
```

# 2. Visualize Optimal Plan
## 2.1 0 splits
```{r}
#get data on optimal plan
matrix_optimal <- redist::get_plans_matrix(pref_smc %>% dplyr::filter(draw == optimal))
colnames(matrix_optimal) <- "district"
optimal_boundary <- cbind(pref_map, dplyr::as_tibble(matrix_optimal))

#get data on gun boundary
gun_boundary <- pref %>%
  filter(code >= (pref$code[1]%/%1000)* 1000 + 300) %>%
  group_by(code) %>%
  summarise(geometry = sf::st_union(geometry))

#get data on koiki renkei area boundary (i.e. 刈谷市(23210)、知立市(23225)、高浜市(23227)、東浦町(23442))
koiki_boundary <- pref_raw %>%
  filter(CITY %in% c("210", "225", "227", "442")) %>% 
  summarise(geometry = sf::st_union(geometry))

#get data on municipality boundary
mun_boundary <- pref_raw %>%
  clean_jcdf() %>%
  group_by(code) %>%
  summarise(geometry = sf::st_union(geometry))

#map with district data + municipality/gun/koiki-renkei boundary
ggplot() +
  geom_sf(data = optimal_boundary, aes(fill = factor(district))) +
  scale_fill_manual(values = as.vector(pals::polychrome(ndists_new)))+
  geom_sf(data = gun_boundary, fill = NA, color = "black", lwd = 3.0) +
  geom_sf(data = mun_boundary, fill = NA, color = "black", lwd = 1.4) +
  #geom_sf(data = koiki_boundary, fill = "grey", alpha = 0.5, color = "plum1", lwd = 0.2) +
  theme(axis.line = element_blank(), axis.text = element_blank(),
        axis.ticks = element_blank(), axis.title = element_blank(),
        legend.title = element_blank(), legend.position = "None",
        panel.background = element_blank())
```

# 3. Co-occurrence
## 3.1 Filter Out Plan with Low Max:min Ratio (Top 10%)
```{r}
good_num_0 <-  functioning_results %>%
  arrange(max_to_min) %>%
  slice(1: as.numeric(length(functioning_results$index)*0.1)) %>%
  select(index)
good_num_0 <- as.vector(t(good_num_0))
sim_smc_pref_0_good <- pref_smc %>%
  filter(draw %in% good_num_0)
```

## 3.2 Obtain co-occurrence matrix
```{r}
m_co_0 = redist::prec_cooccurrence(sim_smc_pref_0_good, sampled_only=TRUE)
```

## 3.3 Use `cluster::agnes()` to create clusters
```{r}
cl_co_0 = cluster::agnes(m_co_0)
plot(as.dendrogram(cl_co_0)) 
prec_clusters_0 = cutree(cl_co_0, 16) #16: number of clusters
```

## 3.4 Convert data on membership to tibble
```{r}
pref_membership_0 <- as_tibble(as.data.frame(prec_clusters_0))
names(pref_membership_0) <- "membership"
```

## 3.5 Obtain co-occurrence ratio
```{r}
cooc_ratio <- vector(length = length(pref$code))
#----define relcomp function--------
relcomp <- function(a, b) {
  comp <- vector()
  for (i in a) {
    if (i %in% a && !(i %in% b)) {
      comp <- append(comp, i)
    }
  }
  return(comp)
}

for (i in 1:length(pref$code)){
  cooc_ratio[i] <- 1 -
    sum(pref$pop[relcomp(prefadj[[i]]+1,
                              which(prec_clusters_0 == prec_clusters_0[i]))] * m_co_0[i, relcomp(prefadj[[i]]+1,
                                                                                                 which(prec_clusters_0 == prec_clusters_0[i]))])/
    sum(pref$pop[prefadj[[i]]+1] * m_co_0[i, prefadj[[i]]+1])
}
```


##3.6 Match membership data with map object
```{r}
pref_0_membership <- cbind(pref, cooc_ratio, pref_membership_0)

#sort membership data by group
pref_0_membership_1 <- pref_0_membership %>% dplyr::filter(membership == 1)
pref_0_membership_2 <- pref_0_membership %>% dplyr::filter(membership == 2)
pref_0_membership_3 <- pref_0_membership %>% dplyr::filter(membership == 3)
pref_0_membership_4 <- pref_0_membership %>% dplyr::filter(membership == 4)
pref_0_membership_5 <- pref_0_membership %>% dplyr::filter(membership == 5)
pref_0_membership_6 <- pref_0_membership %>% dplyr::filter(membership == 6)
pref_0_membership_7 <- pref_0_membership %>% dplyr::filter(membership == 7)
pref_0_membership_8 <- pref_0_membership %>% dplyr::filter(membership == 8)
pref_0_membership_9 <- pref_0_membership %>% dplyr::filter(membership == 9)
pref_0_membership_10 <- pref_0_membership %>% dplyr::filter(membership == 10)
pref_0_membership_11 <- pref_0_membership %>% dplyr::filter(membership == 11)
pref_0_membership_12 <- pref_0_membership %>% dplyr::filter(membership == 12)
pref_0_membership_13 <- pref_0_membership %>% dplyr::filter(membership == 13)
pref_0_membership_14 <- pref_0_membership %>% dplyr::filter(membership == 14)
pref_0_membership_15 <- pref_0_membership %>% dplyr::filter(membership == 15)
pref_0_membership_16 <- pref_0_membership %>% dplyr::filter(membership == 16)
```

##3.7 Plot
```{r}
ggplot() +
  geom_sf(data = pref_0_membership_1, aes(fill = cooc_ratio), show.legend = FALSE) +
  scale_fill_gradient(low="plum1", high="plum4") +

  ggnewscale::new_scale_fill() +
  geom_sf(data = pref_0_membership_2, aes(fill = cooc_ratio), show.legend = FALSE) +
  scale_fill_gradient(low = "paleturquoise", high = "paleturquoise3") +

  ggnewscale::new_scale_fill() +
  geom_sf(data = pref_0_membership_3, aes(fill = cooc_ratio), show.legend = FALSE) +
  scale_fill_gradient(low = "grey40", high = "grey25") +

  ggnewscale::new_scale_fill() +
  geom_sf(data = pref_0_membership_4, aes(fill = cooc_ratio), show.legend = FALSE) +
  scale_fill_gradient(low = "sienna1", high = "sienna4") +

  ggnewscale::new_scale_fill() +
  geom_sf(data = pref_0_membership_5, aes(fill = cooc_ratio), show.legend = FALSE) +
  scale_fill_gradient(low = "dodgerblue", high = "dodgerblue3") +
  
  ggnewscale::new_scale_fill() +
  geom_sf(data = pref_0_membership_6, aes(fill = cooc_ratio), show.legend = FALSE) +
  scale_fill_gradient(low="moccasin", high="lightsalmon") +
  
  ggnewscale::new_scale_fill() +
  geom_sf(data = pref_0_membership_7, aes(fill = cooc_ratio), show.legend = FALSE) +
  scale_fill_gradient(low = "grey90", high = "grey60") +
  
  ggnewscale::new_scale_fill() +
  geom_sf(data = pref_0_membership_8, aes(fill = cooc_ratio), show.legend = FALSE) +
  scale_fill_gradient(low = "darkolivegreen1", high = "darkolivegreen4") +
  
  ggnewscale::new_scale_fill() +
  geom_sf(data = pref_0_membership_9, aes(fill = cooc_ratio), show.legend = FALSE) +
  scale_fill_gradient(low="deepskyblue", high="blue") +
  
  ggnewscale::new_scale_fill() +
  geom_sf(data = pref_0_membership_10, aes(fill = cooc_ratio), show.legend = FALSE) +
  scale_fill_gradient(low = "darkslategray1", high = "cyan2") +
  
  ggnewscale::new_scale_fill() +
  geom_sf(data = pref_0_membership_11, aes(fill = cooc_ratio), show.legend = FALSE) +
  scale_fill_gradient(low="hotpink", high="magenta") +
  
  ggnewscale::new_scale_fill() +
  geom_sf(data = pref_0_membership_12, aes(fill = cooc_ratio), show.legend = FALSE) +
  scale_fill_gradient(low = "greenyellow", high = "lawngreen") +
  
  ggnewscale::new_scale_fill() +
  geom_sf(data = pref_0_membership_13, aes(fill = cooc_ratio), show.legend = FALSE) +
  scale_fill_gradient(low = "violetred1", high = "violetred4") +
  
  ggnewscale::new_scale_fill() +
  geom_sf(data = pref_0_membership_14, aes(fill = cooc_ratio), show.legend = FALSE) +
  scale_fill_gradient(low="red", high="red3") +
  
  ggnewscale::new_scale_fill() +
  geom_sf(data = pref_0_membership_15, aes(fill = cooc_ratio), show.legend = FALSE) +
  scale_fill_gradient(low="purple1", high="purple4") +
  
  ggnewscale::new_scale_fill() +
  geom_sf(data = pref_0_membership_16, aes(fill = cooc_ratio), show.legend = FALSE) +
  scale_fill_gradient(low="gold1", high="darkgoldenrod1") +

  labs(color = "Co-occurrence",
       title = "Co-occurrence Analysis: Plans with Top 10% Max-min Ratio") +
  
 geom_sf(data = gun_boundary, fill = NA, color = "black", lwd = 3.0) +
 geom_sf(data = mun_boundary, fill = NA, color = "black", lwd = 1.4) +
 

  theme(legend.box = "vertical",
        legend.title = element_text(color = "black", size = 7),
        axis.line = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.background = element_blank())
```





