---
title: "Standard Process for Rural Prefectures: Miyagi Prefecture as an Example"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '/home/kentoyamada/R/jcdf/')
```

# I. Simulations
## 1. Set Up and Data Cleaning Process
### 1.1 Set Up
```{r}
library(tidyverse)
set.seed(12345)

# pull functions from jcdf
# set working directory to the function folder
setwd("R")
files.sources = list.files()
sapply(files.sources, source)
# set working directory back to `jcdf`
setwd("..")
```

#### Define Prefectural Data 
```{r}
sim_type <- "smc"
nsims <- 25000
pref_code <- 04
pref_name <- "miyagi"
lakes_removed <- c() 
ndists_new <- 5
ndists_old <- 6
```


### 1.2.Download and Clean Census Data
```{r}
# download census shapefile
pref_raw <- download_shp(pref_code)
dem_pops <- download_pop_demographics(pref_code)

# download 2020 census data
total <- download_2020_census(type = "total")
foreigner <- download_2020_census(type = "foreigner")
#Clean 2020 census
census2020 <- clean_2020_census(total = total, foreigner = foreigner)

# download historical boundary data
old_boundary <- download_old_shp(pref_code = pref_code)

# populations based on historical boundaries
pop_by_old_boundary <- download_2015pop_old(pref_code = pref_code)
```

### 1.3 Use clean_jcdf() function to clean census data
```{r}
pref <- pref_raw %>%
  clean_jcdf() %>%
  dplyr::group_by(code, CITY_NAME) %>%
  dplyr::summarise(geometry = sf::st_union(geometry)) %>%
  dplyr::left_join(census2020, by = c('code')) %>%
  dplyr::rename(pop = pop_national) %>%
  dplyr::select(code, pop, geometry)
```

#### For Miyagi Prefecture only: reflect changes in municipality code
Tomiya-cho became Tomiya-shi in 2016. As we are dealing with census data both from 2015 and 2020, we must fix the municipality code of Tomiya-cho.
```{r}
# fix 富谷町 --> 富谷市 (2016 changes)
pref[which(pref$code == 4423), ]$pop <-  (census2020 %>% dplyr::filter(code == 4216, ))$pop_national
pref[which(pref$code == 4423), ]$code <- 4216
```

### 1.4 Use merge_gun() to make a new column for codes of guns
Miyagi-gun and Kurokawa-gun are split under the enacted plan. Thus, we allow those 2 guns to be split.
```{r}
pref <- merge_gun(pref, c(4401, 4421))
```

### 1.5 Define "Koiki-renkei" Areas
```{r}
ishinomaki_koiki <- c(4202, 4214, 4581)
osaki_koiki <- c(4215, 4444, 4445, 4501, 4505)


pref$koiki_code <- pref$code

#filter out the municipalities that belong to this koiki_renkei area and assign new codes
koiki_1 <- pref %>% filter(code %in% ishinomaki_koiki)
koiki_1$koiki_code <- rep(1, times = length((pref %>% filter(code %in% ishinomaki_koiki))$koiki_code))
koiki_2 <- pref %>% filter(code %in% osaki_koiki)
koiki_2$koiki_code <- rep(2, times = length((pref %>% filter(code %in% osaki_koiki))$koiki_code))

#bind together with the remainder
remainder <- pref %>% filter(code %in% c(ishinomaki_koiki, osaki_koiki) == FALSE)
pref <- dplyr::bind_rows(koiki_1, koiki_2, remainder)
```


## 2. Run Simulations with 0 Municipality Splits (without taking into accoun "Koiki-renkei")
### 2.1 Finalize pref object
In this case, we merge together the gun and treat them as one geographical unit, except for the guns that are split under the status quo.
```{r}
pref_0 <- pref %>%
  dplyr::group_by(gun_code) %>%
  dplyr::summarize(geometry = sf::st_union(geometry),
                   pop = sum(pop),
                   code = code[1],
                   koiki_code = koiki_code[1])
```

### 2.2 Make adjacency graph
```{r}
prefadj_0 <- redist::redist.adjacency(pref_0)
```

### 2.3 Add edges to adjacency graph
In this case, there are no edges to add as there are no areas disconnected from the mainland.
```{r}
ferries_0 <- add_ferries(pref_0)
prefadj_0 <- geomander::add_edge(prefadj_0, ferries_0$V1, ferries_0$V2)
```

### 2.4 Define redist.map object
```{r}
pref_map_0 <- redist::redist_map(pref_0,
                                 ndists = ndists_new,
                                 pop_tol= 0.08,
                                 total_pop = pop,
                                 adj = prefadj_0)
```

###2.5 Run Simulation
```{r}
sim_smc_pref_0 <- redist::redist_smc(pref_map_0,
                                     nsims = nsims,
                                     pop_temper = 0.05)
```

### 2.6 Save results of simulation
```{r}
saveRDS(sim_smc_pref_0, paste("simulation/",
                              as.character(pref_code),
                              "_",
                              as.character(pref_name),
                              "_",
                              as.character(sim_type),
                              "_",
                              as.character(nsims),
                              "_0",
                              ".Rds",
                              sep = ""))
```


## 3. Run Simulations with 1 Municipality Split  (without taking into account "Koiki-renkei")
### 3.1 Split the largest municipality based on its old municipality boundaries
```{r}
old_code <- find_old_codes("04202", pop_by_old_boundary)
new_code <- "04202"
pref_1 <- reflect_old_boundaries(pref, old_boundary, pop_by_old_boundary, old_code, new_code)
pref_1 <- estimate_old_boundary_pop(old_code, new_code, pref_1, census2020)
```

### 3.2 Finalize pref object
In this case, we merge together the gun and treat them as one geographical unit, except for the guns that are split under the status quo.
```{r}
pref_1 <- pref_1 %>%
  dplyr::group_by(gun_code) %>%
  dplyr::summarize(geometry = sf::st_union(geometry),
                   pop = sum(pop),
                   code = code[1],
                   pre_gappei_code = pre_gappei_code[1],
                   koiki_code = koiki_code[1])
```

### 3.3 Make adjacency graph
```{r}
prefadj_1 <- redist::redist.adjacency(pref_1)
```

### 3.4 Add edges to adjacency graph
In this case, there are no edges to add as there are no areas disconnected from the mainland.
```{r}
ferries_1 <- add_ferries(pref_1)
prefadj_1 <- geomander::add_edge(prefadj_1, ferries_1$V1, ferries_1$V2)
```

### 3.5 Define redist.map object
```{r}
pref_map_1 <- redist::redist_map(pref_1,
                                 ndists = ndists_new,
                                 pop_tol= 0.06,
                                 total_pop = pop,
                                 adj = prefadj_1)
```

###3.6 Run Simulation
Impose a constraint to avoid splitting a municipality into more than 2 districts.
```{r}
sim_smc_pref_1 <- redist::redist_smc(pref_map_1,
                                     nsims = nsims,
                                     counties = pref_1$code,
                                     constraints = list(multisplits = list(strength = 100)),
                                     pop_temper = 0.05)
```

### 3.7 Save results of simulation
```{r}
saveRDS(sim_smc_pref_1, paste("simulation/",
                              as.character(pref_code),
                              "_",
                              as.character(pref_name),
                              "_",
                              as.character(sim_type),
                              "_",
                              as.character(nsims),
                              "_1",
                              ".Rds",
                              sep = ""))
```

#II. Analysis
##1. Get Optimal Plan
###1.1 Extract Plans
```{r}
pref_smc_plans_0 <- redist::get_plans_matrix(sim_smc_pref_0)
pref_smc_plans_1 <- redist::get_plans_matrix(sim_smc_pref_1)
```

###1.2 Calculate Max:min ratio
```{r}
wgt_smc_0 <- simulation_weight_disparity_table(sim_smc_pref_0)
wgt_smc_1 <- simulation_weight_disparity_table(sim_smc_pref_1)
```

###1.3 Calculate municipality/gun/koiki renkei splits
```{r}
num_mun_split_1 <- count_splits(pref_smc_plans_1, pref_map_1$code)
mun_split_1 <- redist::redist.splits(pref_smc_plans_1, pref_map_1$code)

num_gun_split_1 <- count_splits(pref_smc_plans_1, pref_map_1$gun_code)
gun_split_1 <- redist::redist.splits(pref_smc_plans_1, pref_map_1$gun_code)

num_koiki_split_1 <- count_splits(pref_smc_plans_1, pref_map_1$koiki_code)
koiki_split_1 <- redist::redist.splits(pref_smc_plans_1, pref_map_1$koiki_code)
```

###1.4 Compile Results
```{r}
results_1 <- data.frame(matrix(ncol = 0, nrow = nrow(wgt_smc_1)))
results_1$max_to_min <- wgt_smc_1$max_to_min
results_1$splits <- n_split_1
results_1$counties_split <- split_1
results_1$index <- 1:nrow(wgt_smc_1)
results_1$dif <-  results_1$splits - results_1$counties_split

zero_multi_results_1 <- results_1 %>% filter(dif == 0)
```

###1.4  Optimal Plan
```{r}
optimal_0 <- wgt_smc_0$draw[which(wgt_smc_0$max_to_min == min(wgt_smc_0$max_to_min))][1]
optimal_1 <- zero_multi_results_1$index[which(zero_multi_results_1$max_to_min == 
                                                min(zero_multi_results_1$max_to_min))][1]
```



```{r}
#get data on optimal plan
matrix_optimal_1 <- redist::get_plans_matrix(sim_smc_pref_1 %>% filter(draw == optimal_1))
colnames(matrix_optimal_1) <- "district"
optimal_boundary_1 <- cbind(pref_map_1, as_tibble(matrix_optimal_1))

#get data on municipality boundary
mun_boundary <- pref %>%
  group_by(code) %>%
  summarise(geometry = sf::st_union(geometry))

#get data on gun boundary
gun_boundary <- pref_0 %>%
  filter(gun_code >= (pref_map_0$code[1]%/%1000)* 1000 + 300) %>%
  group_by(gun_code) %>%
  summarise(geometry = sf::st_union(geometry))

#get data on koiki boundary
koiki_boundary <- pref_0 %>%
  filter(koiki_code < 10) %>%
  group_by(koiki_code) %>%
  summarise(geometry = sf::st_union(geometry))


#map with district data + municipality boundary
ggplot() +
  geom_sf(data = optimal_boundary_1, aes(fill = factor(district))) +
  scale_fill_manual(values = c("green", "purple", "blue", "yellow", "brown")) +
  viridis::scale_color_viridis(discrete = TRUE, option = "turbo") +
  geom_sf(data = mun_boundary, fill = NA, color = "black", lwd = 0.4) +
  geom_sf(data = gun_boundary, fill = NA, color = "black", lwd = 1.0) +
  geom_sf(data = koiki_boundary, fill = "plum1", alpha = 0.3, color = "plum1", lwd = 0.2) +
  theme(axis.line = element_blank(), axis.text = element_blank(),
        axis.ticks = element_blank(), axis.title = element_blank(),
        legend.title = element_blank(), legend.position = "None",
        panel.background = element_blank())

```


#2. Count "Koiki-renkei" splits

#3. Co-occurrence


