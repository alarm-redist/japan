---
title: "34_smc_hiroshima"
output: html_document
  toc: true
  toc_float: true 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '/Users/kentoyamada/Desktop/ALARM Project/jcdf')
```

# I. Simulations
## 1. Set Up and Data Cleaning Process
### 1.1 Set Up
```{r eval=FALSE}
library(tidyverse)
set.seed(12345)

# pull functions from jcdf
# set working directory to the function folder
setwd("R")
files.sources = list.files()
sapply(files.sources, source)
# set working directory back to `jcdf`
setwd("..")
```

#### Define Prefectural Data 
```{r}
sim_type <- "smc"
nsims <- 25000
pref_code <- 34
pref_name <- "hiroshima"
lakes_removed <- c() 
ndists_new <- 6
ndists_old <- 7
n_split <- 4
```

### 1.2.Download and Clean Census Data
```{r warning=FALSE, message=FALSE}
# download census shapefile
pref_raw <- download_shp(pref_code)
dem_pops <- download_pop_demographics(pref_code)

# download 2020 census data
total <- download_2020_census(type = "total")
foreigner <- download_2020_census(type = "foreigner")
#Clean 2020 census
census2020 <- clean_2020_census(total = total, foreigner = foreigner)

# download historical boundary data
old_boundary <- download_old_shp(pref_code = pref_code)

# populations based on historical boundaries
pop_by_old_boundary <- download_2015pop_old(pref_code = pref_code)
```

### 1.3 Use `clean_jcdf()` function to clean census data
```{r warning=FALSE, message=FALSE}
pref <- pref_raw %>%
  clean_jcdf() %>%
  dplyr::group_by(code, CITY_NAME) %>%
  dplyr::summarise(geometry = sf::st_union(geometry)) %>%
  dplyr::left_join(census2020, by = c('code')) %>%
  dplyr::rename(pop = pop_national) %>%
  dplyr::select(code, pop, geometry)
```

### 1.4 Use `merge_gun()` to make a new column for codes of guns
`merge_gun()` assigns each gun a unique code.
```{r}
pref <- merge_gun(pref)
```

### 1.5 Define "Koiki-renkei" Areas
```{r}
#assign which municipality belongs to which koiki renkei area
hiroshima_koiki <- c(34101, 34102, 34103, 34104, 34105, 34106, 34107, 34108,
                     34202, 34203, 34204, 34211, 34212, 34213, 34214, 34215,
                     34302, 34304, 34307, 34309, 34368, 34369, 34431, 34462)
bingo_koiki <- c(34207, 34204, 34205, 34208, 34462, 34545)
hiroshima_chuo_koiki <- c(34202, 34203, 34212, 34215, 34304, 34307, 34309, 34431)


#assign which municipality/gun belongs to which koiki renkei area
#make sure to convert municipality codes into to "gun" codes
koiki_1_codes <-  c(34101, 34102, 34103, 34104, 34105, 34106, 34107, 34108,
                    34202, 34203, 34204, 34211, 34212, 34213, 34214, 34215,
                    34300, 34360, 34420, 34460)
koiki_2_codes <- c(34207, 34204, 34205, 34208, 34460, 34540)
koiki_3_codes <- c(34202, 34203, 34212, 34215, 34300, 34420)
```


## 2. Run Simulations with 0 Municipality Splits (without taking into accoun "Koiki-renkei")
### 2.1 Finalize pref object
We merge together the gun and treat them as one geographical unit. In Hiroshima Prefecture, all the gun are kept together in the same district, so we will merge together all the gun.
```{r}
pref_0 <- sf::st_as_sf(
  pref %>%
    dplyr::group_by(gun_code) %>%
    dplyr::summarize(geometry = sf::st_union(geometry),
                     pop = sum(pop),
                     code = code[1])
)
```

### 2.2 Make adjacency graph
```{r}
prefadj_0 <- redist::redist.adjacency(pref_0)
```

### 2.3 Add edges to adjacency graph
```{r}
if(check_ferries(pref_code) == TRUE){
  # add ferries
  ferries_0 <- add_ferries(pref_0)
  prefadj_0 <- geomander::add_edge(prefadj_0,
                                  ferries_0[, 1],
                                  ferries_0[, 2],
                                  zero = TRUE)
}
```

### 2.4 Define redist.map object
```{r}
pref_map_0 <- redist::redist_map(pref_0,
                                 ndists = ndists_new,
                                 pop_tol= 0.10,
                                 total_pop = pop,
                                 adj = prefadj_0)
```

###2.5 Run Simulation
```{r}
sim_smc_pref_0 <- redist::redist_smc(pref_map_0,
                                     nsims = nsims,
                                     pop_temper = 0.05)
```

### 2.6 Save results of simulation
```{r}
saveRDS(sim_smc_pref_0, paste("simulation/",
                              as.character(pref_code),
                              "_",
                              as.character(pref_name),
                              "_",
                              as.character(sim_type),
                              "_",
                              as.character(nsims),
                              "_0",
                              ".Rds",
                              sep = ""))
```

## 3. Run Simulations with 1 Municipality Split
### 3.1 Split the largest municipality based on its old municipality boundaries
```{r}
split_codes <- pref[order(-pref$pop), ]$code[1:n_split]
new_1 <- as.character(split_codes[1])
old_1 <- find_old_codes(new_1, pop_by_old_boundary)
pref_1 <- reflect_old_boundaries(pref, old_boundary, pop_by_old_boundary, old_1, new_1)
pref_1 <- estimate_old_boundary_pop(old_1, new_1, pref_1, census2020)
```

### 3.2 Finalize pref object
We merge together the gun and treat them as one geographical unit, except for the guns that are split under the status quo. We merge together the gun and treat them as one geographical unit. In Ehime Prefecture, all the gun are kept together in the same district, so we will merge together all the gun.
```{r}
pref_1 <- sf::st_as_sf(
  pref_1 %>%
    dplyr::group_by(gun_code) %>%
    dplyr::summarize(geometry = sf::st_union(geometry),
                   pop = sum(pop),
                   code = code[1],
                   pre_gappei_code = pre_gappei_code[1],
                   koiki_code = koiki_code[1])
)
```


### 3.3 Make adjacency graph
```{r}
prefadj_1 <- redist::redist.adjacency(pref_1)
```

### 3.4 Add edges to adjacency graph
```{r}
if(check_ferries(pref_code) == TRUE){
  # add ferries
  ferries_1 <- add_ferries(pref_1)
  prefadj_1 <- geomander::add_edge(prefadj_1,
                                 ferries_1[, 1],
                                 ferries_1[, 2],
                                 zero = TRUE)
}
```

### 3.5 Define redist.map object
```{r}
pref_map_1 <- redist::redist_map(pref_1,
                                 ndists = ndists_new,
                                 pop_tol= 0.20,
                                 total_pop = pop,
                                 adj = prefadj_1)
```

### 3.6 Run Simulation
```{r}
sim_smc_pref_1 <- redist::redist_smc(pref_map_1,
                                     nsims = nsims,
                                     pop_temper = 0.05)
```

### 3.7 Save results of simulation
```{r}
saveRDS(sim_smc_pref_1, paste("simulation/",
                              as.character(pref_code),
                              "_",
                              as.character(pref_name),
                              "_",
                              as.character(sim_type),
                              "_",
                              as.character(nsims),
                              "_1",
                              ".Rds",
                              sep = ""))
```

# II. Analysis
## 1. Get Optimal Plan
### 1.1 Extract Plans
```{r}
pref_smc_plans_0 <- redist::get_plans_matrix(sim_smc_pref_0)
pref_smc_plans_1 <- redist::get_plans_matrix(sim_smc_pref_1)
```

### 1.2 Calculate Max:min ratio
```{r}
wgt_smc_0 <- simulation_weight_disparity_table(sim_smc_pref_0)
wgt_smc_1 <- simulation_weight_disparity_table(sim_smc_pref_1)
```

### 1.3 Count municipality/gun/koiki renkei splits
Whereas `count_splits()` counts the total number of splits, `redist.splits()` counts the number of geographical units that are split.
```{r}
#assign koiki_renkei area codes
koiki_1 <- pref_0$gun_code
koiki_1[koiki_1 %in% koiki_1_codes] <- 1

koiki_2 <- pref_0$gun_code
koiki_2[koiki_2 %in% koiki_2_codes] <- 2

koiki_3 <- pref_0$gun_code
koiki_3[koiki_3 %in% koiki_3_codes] <- 3
```

```{r}
num_gun_split_0 <- count_splits(pref_smc_plans_0, pref_map_0$gun_code)
gun_split_0 <- redist::redist.splits(pref_smc_plans_0, pref_map_0$gun_code)

koiki_split_0 <- 
  redist::redist.splits(pref_smc_plans_0, koiki_1) + 
  redist::redist.splits(pref_smc_plans_0, koiki_2) +
  redist::redist.splits(pref_smc_plans_0, koiki_3)
```


```{r}
num_mun_split_1 <- count_splits(pref_smc_plans_1, pref_map_1$code)
mun_split_1 <- redist::redist.splits(pref_smc_plans_1, pref_map_1$code)

num_gun_split_1 <- count_splits(pref_smc_plans_1, pref_map_1$gun_code)
gun_split_1 <- redist::redist.splits(pref_smc_plans_1, pref_map_1$gun_code)

num_koiki_split_1 <- count_splits(pref_smc_plans_1, pref_map_1$koiki_code)
koiki_split_1 <- redist::redist.splits(pref_smc_plans_1, pref_map_1$koiki_code)
```


### 1.4 Compile Results
The table created includes information on the max:min ratio as well as the number of municipality/gun/koiki-renkei splits. We also check whether there are cases where a municipality is split into more than 2 districts, in which case such results are filtered out.

```{r}
results_0 <- data.frame(matrix(ncol = 0, nrow = nrow(wgt_smc_0)))
results_0$max_to_min <- wgt_smc_0$max_to_min

#number of gun splits
results_0$num_gun_split <- num_gun_split_0
results_0$gun_split <- gun_split_0

#number of koiki renkei area splits
results_0$koiki_split <- koiki_split_0

results_0$index <- 1:nrow(wgt_smc_0)
```


```{r}
# Post-processing: filter out plans with discontiguous districts

#in this case, Aki-ku(Hiroshima-shi; code: 34107) and Aki-gun (code: 34300) must be in the same district to avoid creating discontiguous districts
contiguous <- 1:25000
for(i in 1:25000){
   contiguous[i] <- 
     as.integer(pref_smc_plans_0[,i][which(pref_0$gun_code == 34107)] == pref_smc_plans_0[,i][which(pref_0$gun_code == 34300)])
}
results_0$contiguous <- contiguous

#Ferry routes connect Takehara-shi (34203), Higashihiroshima-shi (34212), and Kure-shi (34202) to Osakikamijima-cho.
#However, Takehara-shi and Kure-shi are in different not connected by land.
#Thus, we must make sure to avoid a situation in which Takehara-shi and Takehara-shi both belong to the district that is different from the district Higashihiroshima-shi belongs to.
ferry_discontiguity <- 1:25000
for(i in 1:25000){
   ferry_discontiguity[i] <- 
     as.integer(
      #We must avoid a situation in which Kure-shi (34202) and Takehara-shi(34203) belong to the same district
      pref_smc_plans_0[,i][which(pref_0$gun_code == 34202)] == pref_smc_plans_0[,i][which(pref_0$gun_code == 34203)]&
      #whereby that district is differnt from the district Higashihiroshima-shi (34212) belongs to
      pref_smc_plans_0[,i][which(pref_0$gun_code == 34202)] != pref_smc_plans_0[,i][which(pref_0$gun_code == 34212)]
      )
}
results_0$ferry_discontiguity <- ferry_discontiguity
```

```{r}
results_1 <- data.frame(matrix(ncol = 0, nrow = nrow(wgt_smc_1)))
results_1$max_to_min <- wgt_smc_1$max_to_min

#number of municipality splits
results_1$nun_mun_split <- num_mun_split_1
results_1$mun_split <- mun_split_1

#check whether there are cases where a municipality is split into more than 2 districts
results_1$multi <-  results_1$nun_mun_split - results_1$mun_split

#number of gun splits
results_1$num_gun_split <- num_gun_split_1
results_1$gun_split <- gun_split_1

#number of koiki renkei area splits
results_1$num_koiki_split <- num_koiki_split_1
results_1$koiki_split <- koiki_split_1

results_1$index <- 1:nrow(wgt_smc_1)

#filter out cases where a municipality is split into more than 2 districts
zero_multi_results_1 <- results_1 %>% filter(multi == 0)
```

### 1.5  Optimal Plan
```{r}
contiguous_results_0 <- results_0[which(results_0$contiguous == 1 & results_0$ferry_discontiguity == 0), ]
optimal_0_without_tobichi <- contiguous_results_0$index[which(contiguous_results_0$max_to_min ==
                                                                min(contiguous_results_0$max_to_min))][1]
results_0[optimal_0_without_tobichi,]
```

```{r}
optimal_1 <- zero_multi_results_1$index[which(zero_multi_results_1$max_to_min == 
                                                min(zero_multi_results_1$max_to_min))][1]
results_1[optimal_1,]
```

# 2. Visualize Optimal Plan
## 2.1 0 splits
```{r}
#get data on optimal plan
matrix_optimal_0 <- redist::get_plans_matrix(sim_smc_pref_0 %>% filter(draw == optimal_0_without_tobichi))
colnames(matrix_optimal_0) <- "district"
optimal_boundary_0 <- cbind(pref_map_0, as_tibble(matrix_optimal_0))

#get data on gun boundary
gun_boundary <- pref_0 %>%
  filter(gun_code >= (pref_map_0$code[1]%/%1000)* 1000 + 300) %>%
  group_by(gun_code) %>%
  summarise(geometry = sf::st_union(geometry))

#get data on koiki renkei area boundary
koiki_boundary_1 <- pref %>%
  filter(code %in% hiroshima_koiki) %>%
  summarise(geometry = sf::st_union(geometry))

koiki_boundary_2 <- pref %>%
  filter(code %in% bingo_koiki) %>%
  summarise(geometry = sf::st_union(geometry))

koiki_boundary_2 <- pref %>%
  filter(code %in% hiroshima_chuo_koiki) %>%
  summarise(geometry = sf::st_union(geometry))

#map with district data + municipality/gun/koiki-renkei boundary
ggplot() +
  geom_sf(data = optimal_boundary_0, aes(fill = factor(district))) +
  scale_fill_manual(values = c("orange", "green", "blue", "yellow", "brown", "purple")) +
  geom_sf(data = gun_boundary, fill = NA, color = "black", lwd = 1.0) +
  #geom_sf(data = koiki_boundary_1, fill = "plum1", alpha = 0.5, color = "plum1", lwd = 0.2) +
  theme(axis.line = element_blank(), axis.text = element_blank(),
        axis.ticks = element_blank(), axis.title = element_blank(),
        legend.title = element_blank(), legend.position = "None",
        panel.background = element_blank())
```

## 2.2 Allowing Up to 1 Municipality Split
```{r}
#get data on optimal plan
matrix_optimal_1 <- redist::get_plans_matrix(sim_smc_pref_1 %>% filter(draw == optimal_1))
colnames(matrix_optimal_1) <- "district"
optimal_boundary_1 <- cbind(pref_map_1, as_tibble(matrix_optimal_1))

#get data on municipality boundary
mun_boundary <- pref_0 %>%
  group_by(code) %>%
  summarise(geometry = sf::st_union(geometry))

#map with district data + municipality/gun/koiki-renkei boundary
ggplot() +
  geom_sf(data = optimal_boundary_1, aes(fill = factor(district))) +
  scale_fill_manual(values = c("1" = "blue", "2" = "brown", "3" = "green")) +
  geom_sf(data = mun_boundary, fill = NA, color = "black", lwd = 0.4) +
  geom_sf(data = gun_boundary, fill = NA, color = "black", lwd = 1.0) +
  geom_sf(data = koiki_boundary, fill = "plum1", alpha = 0.5, color = "plum1", lwd = 0.2) +
  theme(axis.line = element_blank(), axis.text = element_blank(),
        axis.ticks = element_blank(), axis.title = element_blank(),
        legend.title = element_blank(), legend.position = "None",
        panel.background = element_blank())

```

# 3. Co-occurrence
## 3.1 Filter Out Plan with Low Max:min Ratio (Top 10%)
```{r}
good_num_0 <-  results_0 %>%
  arrange(max_to_min) %>%
  slice(1: as.numeric(nsims*0.1)) %>%
  select(index)
good_num_0 <- as.vector(t(good_num_0))
sim_smc_pref_0_good <- sim_smc_pref_0 %>%
  filter(draw %in% good_num_0)
```

## 3.2 Obtain co-occurrence matrix
```{r}
m_co_0 = redist::prec_cooccurrence(sim_smc_pref_0_good, sampled_only=TRUE)
```


## 3.3 Use `cluster::agnes()` to create clusters
```{r}
cl_co_0 = cluster::agnes(m_co_0)
plot(as.dendrogram(cl_co_0)) 
prec_clusters_0 = cutree(cl_co_0, 3) #3: number of clusters
```

## 3.4 Convert data on membership to tibble
```{r}
pref_membership_0 <- as_tibble(as.data.frame(prec_clusters_0))
names(pref_membership_0) <- "membership"
```


## 3.5 Obtain co-occurrence ratio
```{r}
cooc_ratio <- vector(length = length(pref_0$code))
#----define relcomp function--------
relcomp <- function(a, b) {
  comp <- vector()
  for (i in a) {
    if (i %in% a && !(i %in% b)) {
      comp <- append(comp, i)
    }
  }
  return(comp)
}


for (i in 1:length(pref_0$code))
{
  cooc_ratio[i] <- 1 -
    sum(pref_0$pop[relcomp(prefadj_0[[i]]+1,
                              which(prec_clusters_0 == prec_clusters_0[i]))] * m_co_0[i, relcomp(prefadj_0[[i]]+1,
                                                                                                 which(prec_clusters_0 == prec_clusters_0[i]))])/
    sum(pref_0$pop[prefadj_0[[i]]+1] * m_co_0[i, prefadj_0[[i]]+1])
}

```


##3.6 Match membership data with map object
```{r}
pref_0_membership <- cbind(pref_0, cooc_ratio, pref_membership_0)

#sort membership data by group
pref_0_membership_1 <- pref_0_membership %>% dplyr::filter(membership == 1)
pref_0_membership_2 <- pref_0_membership %>% dplyr::filter(membership == 2)
pref_0_membership_3 <- pref_0_membership %>% dplyr::filter(membership == 3)
```

##3.7 Plot
```{r}
ggplot() +
  geom_sf(data = pref_0_membership_1, aes(fill = cooc_ratio), show.legend = FALSE) +
  scale_fill_gradient(low="palegreen", high="green") +

  ggnewscale::new_scale_fill() +
  geom_sf(data = pref_0_membership_2, aes(fill = cooc_ratio), show.legend = FALSE) +
  scale_fill_gradient(low = "skyblue", high = "blue") +

  ggnewscale::new_scale_fill() +
  geom_sf(data = pref_0_membership_3, aes(fill = cooc_ratio), show.legend = FALSE) +
  scale_fill_gradient(low = "brown1", high = "brown4") +

  labs(color = "Co-occurrence",
       title = "Co-occurrence Analysis: Plans with Top 10% Max-min Ratio") +
  
  geom_sf(data = gun_boundary, fill = NA, color = "black", lwd = 1.0) +

  theme(legend.box = "vertical",
        legend.title = element_text(color = "black", size = 7),
        axis.line = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.background = element_blank())
```

