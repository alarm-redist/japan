---
title: "23_ms_aichi"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#knitr::opts_knit$set(root.dir = '/Users/kentoyamada/Desktop/ALARM Project/jcdf')
#knitr::opts_knit$set(root.dir = '/home/kentoyamada/R/jcdf/')
```

# I. Simulations
## 1. Set Up and Data Cleaning Process
### 1.1 Set Up
```{r eval=FALSE}
library(tidyverse)
set.seed(12345)
# pull functions from jcdf
# set working directory to the function folder
setwd("R")
files.sources = list.files()
sapply(files.sources, source)
# set working directory back to `jcdf`
setwd("..")
```

#### Define Prefectural Data 
```{r}
sim_type <- "smc"
nsims <- 25000
pref_code <- 23
pref_name <- "aichi"
lakes_removed <- c() 
ndists_new <- 16
ndists_old <- 15
n_split <- 3
```

### 1.2.Download and Clean Census Data
```{r warning=FALSE, message=FALSE}
# download census shapefile
pref_raw <- download_shp(pref_code)
dem_pops <- download_pop_demographics(pref_code)
# download 2020 census data
total <- download_2020_census(type = "total")
foreigner <- download_2020_census(type = "foreigner")
#Clean 2020 census
census2020 <- clean_2020_census(total = total, foreigner = foreigner)
# download historical boundary data
old_boundary <- download_old_shp(pref_code = pref_code)
# populations based on historical boundaries
pop_by_old_boundary <- download_2015pop_old(pref_code = pref_code)
```

### 1.3 Use `clean_jcdf()` function to clean census data
```{r warning=FALSE, message=FALSE}
pref <- pref_raw %>%
  clean_jcdf() %>%
  dplyr::select(code, KIHON1, JINKO, geometry)
pref <- calc_kokumin(pref, dem_pops)
#Estimate 2020 pop. <- estimate_2020_pop(pref, census2020) %>%
  dplyr::select(code, KIHON1, pop_estimate, geometry) %>%
  dplyr::rename(subcode = KIHON1, pop = pop_estimate)
```

### 1.4 Merge together gun
Under the enacted plan, all the gun in Aichi prefecture are respected under the status quo. Thus, we merge together the gun so as not to split them.
```{r}
#merge Aichi gun
aichi <- pref %>%
  dplyr::filter(code == 23302)
aichi$code <- 23300
aichi <- aichi %>%
  dplyr::group_by(code) %>%
  dplyr::summarise(pop = sum(pop), geometry = sf::st_union(geometry))
aichi$subcode <- "0000"

#merge Nishikasugai gun
nishikasugai <- pref %>%
  dplyr::filter(code == 23342)
nishikasugai$code <- 23340
nishikasugai <- nishikasugai %>%
  dplyr::group_by(code) %>%
  dplyr::summarise(pop = sum(pop), geometry = sf::st_union(geometry))
nishikasugai$subcode <- "0000"

#merge Niwa gun
niwa <- pref %>%
  dplyr::filter(code %in% c(23361, 23362))
niwa$code <- 23360
niwa <- niwa %>%
  dplyr::group_by(code) %>%
  dplyr::summarise(pop = sum(pop), geometry = sf::st_union(geometry))
niwa$subcode <- "0000"

#merge Ama gun
ama <- pref %>%
  dplyr::filter(code %in% c(23424, 23425, 23427))
ama$code <- 23420
ama <- ama %>%
  dplyr::group_by(code) %>%
  dplyr::summarise(pop = sum(pop), geometry = sf::st_union(geometry))
ama$subcode <- "0000"

#merge Chita gun
chita <- pref %>%
  dplyr::filter(code %in% c(23441, 23442, 23445, 23446, 23447))
chita$code <- 23440
chita <- chita %>%
  dplyr::group_by(code) %>%
  dplyr::summarise(pop = sum(pop), geometry = sf::st_union(geometry))
chita$subcode <- "0000"

#merge Nukata gun
nukata <- pref %>%
  dplyr::filter(code == 23501)
nukata$code <- 23500
nukata <- nukata %>%
  dplyr::group_by(code) %>%
  dplyr::summarise(pop = sum(pop), geometry = sf::st_union(geometry))
nukata$subcode <- "0000"

#merge Kitashitara gun
kitashitara <- pref %>%
  dplyr::filter(code %in% c(23561, 23562, 23563))
kitashitara$code <- 23560
kitashitara <- kitashitara %>%
  dplyr::group_by(code) %>%
  dplyr::summarise(pop = sum(pop), geometry = sf::st_union(geometry))
kitashitara$subcode <- "0000"

#merge back together
pref_non_gun <- pref %>%
  dplyr::filter(code %in% c(23302, 
                           23342,
                           23361, 23362,
                           23424, 23425, 23427,
                           23441, 23442, 23445, 23446, 23447,
                           23501,
                           23561, 23562, 23563) == FALSE)

#now pref is an object with 0 gun splits
pref <- dplyr::bind_rows(pref_non_gun, aichi, nishikasugai, niwa, ama, chita, 
                         nukata, kitashitara)
```

### 1.5 Define "Koiki-renkei" Areas
```{r}
#assign which municipality belongs to which koiki renkei area
kinuura_koiki <- c(23210, 23225, 23227, 23300)  #23300 Aichigun, Togo cho
```

## 2. Run Simulations 

### 2.1 Finalize pref object
No additional steps needed

### 2.2 Make adjacency graph
```{r}
prefadj <- redist::redist.adjacency(pref)
```

### 2.3 Add edges to adjacency graph
The add_ferries() function connects 西尾市一色町佐久島 (no: 4251, code: 23213, subcode: 7240) with 西尾市一色町坂田新田 (no: 4239, code: 23213, subcode: 7120).

In addition, 名古屋市港区金城ふ頭 (no: 973, code: 23111, subcode: 0460) appears to be disconnected. We manually connect it to three areas: 名古屋市港区空見町(code: 23111, subcode: 1080), 名古屋市港区潮見町 (code: 23111, subcode: 0740), and 愛知県海部郡飛島村金岡(code: 23420)

We also manually connect 常滑市セントレア町(no: 4403, code: 23216, subcode: 0960) to 常滑市りんくう町 (code: code: 23216, subcode: 0950)
```{r}
if(check_ferries(pref_code) == TRUE){
  # add ferries
  ferries <- add_ferries(pref)
  prefadj <- geomander::add_edge(prefadj,
                                 ferries[, 1],
                                 ferries[, 2],
                                 zero = TRUE)
}
```

```{r}
prefadj <- geomander::add_edge(prefadj, 
                               which(pref$code == 23111 & pref$subcode == "0460"), #名古屋市港区金城ふ頭 
                               which(pref$code == 23111 & pref$subcode == "1080")) #名古屋市港区空見町
prefadj <- geomander::add_edge(prefadj, 
                               which(pref$code == 23111 & pref$subcode == "0460"), #名古屋市港区金城ふ頭 
                               which(pref$code == 23111 & pref$subcode == "0740")) #名古屋市港区潮見町
prefadj <- geomander::add_edge(prefadj, 
                               which(pref$code == 23111 & pref$subcode == "0460"),  #名古屋市港区金城ふ頭 
                               which(pref$code == 23420)) #愛知県海部郡飛島村金岡
prefadj <- geomander::add_edge(prefadj, 
                               which(pref$code == 23216 & pref$subcode == "0960"), #常滑市セントレア町 
                               which(pref$code == 23216 & pref$subcode == "0950")) #常滑市りんくう町
```


### 2.4 Define redist.map object
```{r}
pref_map <- redist::redist_map(pref,
                               ndists = ndists_new,
                               pop_tol= 0.15,
                               total_pop = pop,
                               adj = prefadj)
```

###2.5 Run Simulation
```{r}
#define constraints
constr = redist::redist_constr(pref_map)
constr = redist::add_constr_splits(constr, strength=2)
constr = redist::add_constr_multisplits(constr, strength = 10)

#run redist_smc
pref_smc <- redist::redist_smc(
  map = pref_map,
  nsims = 10,
  counties = pref$code,
  constraints = constr
)
```

### 2.6 Save results of simulation
```{r}
saveRDS(pref_smc, paste("simulation/",
                        as.character(pref_code),
                        "_",
                        as.character(pref_name),
                        "_",
                        as.character(sim_type),
                        "_",
                        as.character(nsims),
                        "_0",
                        ".Rds",
                        sep = ""))
```

# II. Analysis
## 1. Get Optimal Plan
### 1.1 Extract Plans
```{r}
pref_smc_plans <- redist::get_plans_matrix(pref_smc)
```

### 1.2 Calculate Max:min ratio
```{r}
wgt_smc <- simulation_weight_disparity_table(pref_smc)
```

### 1.3 Count municipality/gun/koiki renkei splits
Whereas `count_splits()` counts the total number of splits, `redist.splits()` counts the number of geographical units that are split.
```{r}
#assign koiki_renkei area codes for simulation with 0 split
koiki_1 <- pref$code
koiki_1[koiki_1 %in% kinuura_koiki] <- 1
koiki_1[koiki_1 %in% kinuura_koiki == FALSE] <- 0

#count the number of koiki-renkei areas that are split
koiki_split <- redist::redist.splits(pref_smc_plans, koiki_1)

#count the number of municipality splits
num_mun_split <- count_splits(pref_smc_plans, pref_map$code)
mun_split <- redist::redist.splits(pref_smc_plans, pref_map$code)
```

### 1.4 Compile Results
The table created includes information on the max:min ratio as well as the number of municipality/gun/koiki-renkei splits. We also check whether there are cases where a municipality is split into more than 2 districts, in which case such results are filtered out.

```{r}
results <- data.frame(matrix(ncol = 0, nrow = nrow(wgt_smc)))
results$max_to_min <- wgt_smc$max_to_min
#number of municipality splits
results$nun_mun_split <- num_mun_split
results$mun_split <- mun_split
#check whether there are cases where a municipality is split into more than 2 districts
results$multi <-  results$nun_mun_split - results$mun_split
#number of koiki renkei area splits
results$koiki_split <- koiki_split
results$index <- 1:nrow(wgt_smc)
```

### 1.5  Optimal Plan
The optimal plan is the plan that has the smallest max:min ratio out of all plans that do not have discontiguous districts and do not split a municipality into more than 2 districts.
```{r}
functioning_results <- results[which(results$multi == 0 ), ]
optimal <- functioning_results$index[which(functioning_results$max_to_min ==
                                     min(functioning_results$max_to_min))][1]
results[optimal,]
```

# 2. Visualize Optimal Plan
## 2.1 0 splits
```{r}
#get data on optimal plan
matrix_optimal <- redist::get_plans_matrix(pref_smc %>% filter(draw == 1))
colnames(matrix_optimal) <- "district"
optimal_boundary <- cbind(pref_map, as_tibble(matrix_optimal))

#get data on gun boundary
gun_boundary <- pref %>%
  filter(code >= (pref$code[1]%/%1000)* 1000 + 300) %>%
  group_by(code) %>%
  summarise(geometry = sf::st_union(geometry))

#get data on koiki renkei area boundary (i.e. 刈谷市(23210)、知立市(23225)、高浜市(23227)、東浦町(23442))
koiki_boundary <- pref_raw %>%
  filter(CITY %in% c("210", "225", "227", "442")) %>% 
  summarise(geometry = sf::st_union(geometry))

#get data on municipality boundary
mun_boundary <- pref %>%
  group_by(code) %>%
  summarise(geometry = sf::st_union(geometry))

#map with district data + municipality/gun/koiki-renkei boundary
ggplot() +
  geom_sf(data = optimal_boundary, aes(fill = factor(district))) +
  #scale_fill_manual(values = c("orange", "green", "blue", "yellow", "brown", "purple")) +
  geom_sf(data = gun_boundary, fill = NA, color = "black", lwd = 3.0) +
  geom_sf(data = mun_boundary, fill = NA, color = "black", lwd = 1.4) +
  #geom_sf(data = koiki_boundary, fill = "grey", alpha = 0.5, color = "plum1", lwd = 0.2) +
  theme(axis.line = element_blank(), axis.text = element_blank(),
        axis.ticks = element_blank(), axis.title = element_blank(),
        legend.title = element_blank(), legend.position = "None",
        panel.background = element_blank())
```


```{r}
multi_by_mun <- NULL
for(i in unique(optimal_boundary$code)){
  a <- length(unique((optimal_boundary %>% filter(code == i))$district))
  multi_by_mun <- c(multi_by_mun, a)
}

unique(optimal_boundary$code)[11]
```

